#!/usr/bin/env python3
"""
Immich Transfer Tool
Transfer photos between users in Immich, including faces and metadata.
"""

import requests
import psycopg2
import uuid
import os
from typing import Optional

# Try to import config, or use empty values
try:
    from config import API_URL, API_KEY, DB_CONFIG
except ImportError:
    API_URL = ""
    API_KEY = ""
    DB_CONFIG = {"host": "", "port": 5432, "database": "immichdb", "user": "immich", "password": ""}


def clear_screen():
    """Clear terminal screen"""
    os.system('cls' if os.name == 'nt' else 'clear')


def print_header():
    """Print application header"""
    print()
    print("  ╔══════════════════════════════════════════════════════════╗")
    print("  ║                   IMMICH TRANSFER TOOL                   ║")
    print("  ║          Transfer photos between users safely            ║")
    print("  ║                                                          ║")
    print("  ║            github.com/pedrorj2/immich-transfer           ║")
    print("  ╚══════════════════════════════════════════════════════════╝")
    print()


def print_section(title: str):
    """Print a section header"""
    print(f"\n  ┌{'─' * (len(title) + 2)}┐")
    print(f"  │ {title} │")
    print(f"  └{'─' * (len(title) + 2)}┘\n")


def setup_config():
    """Interactive configuration setup"""
    clear_screen()
    print_header()
    print_section("CONFIGURATION SETUP")
    
    # API URL
    print("  Immich API URL")
    print("  Example: http://192.168.1.6:2283")
    api_url = input("  > ").strip()
    if not api_url.endswith("/api"):
        api_url = api_url.rstrip("/") + "/api"
    
    # API Key
    print("\n  Admin API Key")
    print("  Get it from: Immich → Profile → Account Settings → API Keys")
    api_key = input("  > ").strip()
    
    # Database
    print_section("PostgreSQL Configuration")
    
    print("  Database Host")
    print("  Example: 192.168.1.6 or immich_postgres (if running on same server)")
    db_host = input("  > ").strip()
    
    print("\n  Database Port [5432]")
    db_port = input("  > ").strip() or "5432"
    
    print("\n  Database Name [immichdb]")
    db_name = input("  > ").strip() or "immichdb"
    
    print("\n  Database Username [immich]")
    db_user = input("  > ").strip() or "immich"
    
    print("\n  Database Password")
    print("  Find it with: docker exec -t immich_postgres env | grep POSTGRES_PASSWORD")
    db_pass = input("  > ").strip()
    
    # Write config file
    config_content = f'''# Immich Transfer Configuration
# Auto-generated by setup

# Immich API URL
API_URL = "{api_url}"

# API Key with admin permissions
API_KEY = "{api_key}"

# PostgreSQL connection
DB_CONFIG = {{
    "host": "{db_host}",
    "port": {db_port},
    "database": "{db_name}",
    "user": "{db_user}",
    "password": "{db_pass}"
}}
'''
    
    config_path = os.path.join(os.path.dirname(__file__), "config.py")
    with open(config_path, "w") as f:
        f.write(config_content)
    
    print(f"\n  ✓ Configuration saved to {config_path}")
    input("\n  Press Enter to continue...")
    return api_url, api_key, {"host": db_host, "port": int(db_port), "database": db_name, "user": db_user, "password": db_pass}


def clear_config():
    """Clear configuration file"""
    config_content = '''# Immich Transfer Configuration
# Run the tool to set up interactively

API_URL = ""
API_KEY = ""
DB_CONFIG = {
    "host": "",
    "port": 5432,
    "database": "immichdb",
    "user": "immich",
    "password": ""
}
'''
    config_path = os.path.join(os.path.dirname(__file__), "config.py")
    with open(config_path, "w") as f:
        f.write(config_content)
    print("\n  ✓ Configuration cleared")
    input("\n  Press Enter to continue...")


def check_config():
    """Check if config is valid, offer setup if not"""
    global API_URL, API_KEY, DB_CONFIG
    
    if not API_URL or not API_KEY or not DB_CONFIG.get("host") or not DB_CONFIG.get("password"):
        print("\n  ⚠ Configuration not found or incomplete.")
        choice = input("  Run setup now? (y/n): ").strip().lower()
        if choice == 'y':
            API_URL, API_KEY, DB_CONFIG = setup_config()
            return True
        else:
            print("  Please edit config.py manually.")
            return False
    return True


class ImmichTransfer:
    def __init__(self, api_url=None, api_key=None, db_config=None):
        self.api_url = api_url or API_URL
        self.api_key = api_key or API_KEY
        self.db_config = db_config or DB_CONFIG
        self.headers = {
            "x-api-key": self.api_key,
            "Content-Type": "application/json"
        }
        self.conn = None
    
    # ==================== API METHODS ====================
    
    def get_users(self) -> list:
        """Get list of users"""
        resp = requests.get(f"{self.api_url}/users", headers=self.headers)
        resp.raise_for_status()
        return resp.json()
    
    def get_albums(self) -> list:
        """Get list of albums (via API, only current user's)"""
        resp = requests.get(f"{self.api_url}/albums", headers=self.headers)
        resp.raise_for_status()
        return resp.json()
    
    def get_all_albums_db(self) -> list:
        """Get ALL albums from all users via DB"""
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT a.id, a."albumName", a."ownerId", u.name as owner_name,
                   (SELECT COUNT(*) FROM album_asset aa WHERE aa."albumId" = a.id) as asset_count
            FROM album a
            LEFT JOIN "user" u ON a."ownerId" = u.id
            ORDER BY u.name, a."albumName"
        """)
        albums = []
        for row in cur.fetchall():
            albums.append({
                "id": row[0],
                "albumName": row[1],
                "ownerId": row[2],
                "ownerName": row[3],
                "assetCount": row[4]
            })
        cur.close()
        return albums
    
    def get_album_assets(self, album_id: str) -> list:
        """Get asset IDs from an album"""
        resp = requests.get(f"{self.api_url}/albums/{album_id}", headers=self.headers)
        resp.raise_for_status()
        album = resp.json()
        return [asset["id"] for asset in album.get("assets", [])]
    
    def get_tags(self) -> list:
        """Get list of tags"""
        resp = requests.get(f"{self.api_url}/tags", headers=self.headers)
        resp.raise_for_status()
        return resp.json()
    
    # ==================== DATABASE METHODS ====================
    
    def connect_db(self):
        """Connect to database"""
        if self.conn is None or self.conn.closed:
            self.conn = psycopg2.connect(**self.db_config)
        return self.conn
    
    def close_db(self):
        """Close database connection"""
        if self.conn and not self.conn.closed:
            self.conn.close()
    
    def get_assets_by_album(self, album_id: str) -> list:
        """Obtiene asset IDs de un álbum desde la DB"""
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT "assetId" FROM album_asset WHERE "albumId" = %s
        """, (album_id,))
        assets = [row[0] for row in cur.fetchall()]
        cur.close()
        return assets
    
    def get_faces_for_assets(self, asset_ids: list) -> list:
        """Obtiene las caras asociadas a una lista de assets"""
        if not asset_ids:
            return []
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT af.id, af."assetId", af."personId", p."ownerId", p.name
            FROM asset_face af
            LEFT JOIN person p ON af."personId" = p.id
            WHERE af."assetId" = ANY(%s)
        """, (asset_ids,))
        faces = cur.fetchall()
        cur.close()
        return faces
    
    def get_persons_for_assets(self, asset_ids: list) -> dict:
        """
        Obtiene las personas únicas que aparecen en los assets.
        Retorna dict con info de cada persona y si tiene caras fuera de estos assets.
        """
        if not asset_ids:
            return {}
        
        conn = self.connect_db()
        cur = conn.cursor()
        
        # Personas que aparecen en los assets a transferir
        cur.execute("""
            SELECT DISTINCT af."personId"
            FROM asset_face af
            WHERE af."assetId"::text = ANY(%s) AND af."personId" IS NOT NULL
        """, (asset_ids,))
        person_ids = [row[0] for row in cur.fetchall()]
        
        if not person_ids:
            cur.close()
            return {}
        
        persons = {}
        for person_id in person_ids:
            # Info de la persona
            cur.execute("""
                SELECT id, "ownerId", name, "thumbnailPath", "isHidden", "birthDate", 
                       "faceAssetId", "isFavorite", color
                FROM person WHERE id = %s
            """, (person_id,))
            person_data = cur.fetchone()
            
            if not person_data:
                continue
            
            # Contar caras dentro y fuera de los assets a transferir
            cur.execute("""
                SELECT 
                    COUNT(*) FILTER (WHERE "assetId"::text = ANY(%s)) as faces_in_transfer,
                    COUNT(*) FILTER (WHERE "assetId"::text != ALL(%s)) as faces_outside
                FROM asset_face
                WHERE "personId" = %s
            """, (asset_ids, asset_ids, person_id))
            counts = cur.fetchone()
            
            persons[person_id] = {
                "id": person_data[0],
                "ownerId": person_data[1],
                "name": person_data[2],
                "thumbnailPath": person_data[3],
                "isHidden": person_data[4],
                "birthDate": person_data[5],
                "faceAssetId": person_data[6],
                "isFavorite": person_data[7],
                "color": person_data[8],
                "faces_in_transfer": counts[0],
                "faces_outside": counts[1]
            }
        
        cur.close()
        return persons
    
    def transfer_assets(self, asset_ids: list, new_owner_id: str) -> int:
        """Transfiere la propiedad de los assets"""
        if not asset_ids:
            return 0
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE asset SET "ownerId" = %s WHERE id::text = ANY(%s)
        """, (new_owner_id, asset_ids))
        count = cur.rowcount
        conn.commit()
        cur.close()
        return count
    
    def transfer_person(self, person_id: str, new_owner_id: str):
        """Transfiere una persona completa a otro usuario"""
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE person SET "ownerId" = %s WHERE id = %s
        """, (new_owner_id, person_id))
        conn.commit()
        cur.close()
    
    def duplicate_person_for_user(self, person_id: str, new_owner_id: str, asset_ids: list) -> Optional[str]:
        """
        Duplica una persona para el nuevo usuario.
        Solo re-vincula las caras de los assets transferidos.
        Retorna el ID de la nueva persona.
        """
        conn = self.connect_db()
        cur = conn.cursor()
        
        try:
            # Obtener datos de la persona original
            cur.execute("""
                SELECT name, "isHidden", "birthDate", "isFavorite", color
                FROM person WHERE id = %s
            """, (person_id,))
            original = cur.fetchone()
            
            if not original:
                cur.close()
                return None
            
            # Crear nueva persona para el nuevo usuario (sin faceAssetId inicialmente)
            new_person_id = str(uuid.uuid4())
            cur.execute("""
                INSERT INTO person (id, "ownerId", name, "isHidden", "birthDate", "isFavorite", color, "createdAt", "updatedAt")
                VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
            """, (new_person_id, new_owner_id, original[0], original[1], original[2], original[3], original[4]))
            
            # Re-vincular las caras de los assets transferidos a la nueva persona
            cur.execute("""
                UPDATE asset_face 
                SET "personId" = %s 
                WHERE "personId" = %s AND "assetId"::text = ANY(%s)
            """, (new_person_id, person_id, asset_ids))
            
            # Obtener una cara de la nueva persona para usarla como foto de perfil
            cur.execute("""
                SELECT id FROM asset_face WHERE "personId" = %s LIMIT 1
            """, (new_person_id,))
            face_row = cur.fetchone()
            
            if face_row:
                cur.execute("""
                    UPDATE person SET "faceAssetId" = %s WHERE id = %s
                """, (face_row[0], new_person_id))
            
            conn.commit()
            cur.close()
            return new_person_id
            
        except Exception as e:
            conn.rollback()
            cur.close()
            raise e
    
    def transfer_album_with_faces(self, album_id: str, new_owner_id: str, dry_run: bool = True) -> dict:
        """
        Transfer an album with all associated faces.
        
        Args:
            album_id: Album ID to transfer
            new_owner_id: Destination user ID
            dry_run: If True, only simulate without making changes
        
        Returns:
            dict with operation summary
        """
        result = {
            "assets_transferred": 0,
            "persons_transferred": 0,
            "persons_duplicated": 0,
            "errors": []
        }
        
        # 1. Get album assets
        asset_ids = self.get_assets_by_album(album_id)
        if not asset_ids:
            result["errors"].append("No assets found in album")
            return result
        
        print(f"\n  ┌────────────────────────────────────────────────────┐")
        print(f"  │              ALBUM TRANSFER ANALYSIS                │")
        print(f"  └────────────────────────────────────────────────────┘")
        print(f"\n  Assets to transfer: {len(asset_ids)}")
        
        # 2. Analyze affected persons
        persons = self.get_persons_for_assets(asset_ids)
        print(f"  Persons detected: {len(persons)}")
        
        persons_to_transfer = []  # Persons only in these assets
        persons_to_duplicate = []  # Persons in both
        
        if persons:
            print(f"\n  Person analysis:")
        for pid, pdata in persons.items():
            if pdata["faces_outside"] == 0:
                persons_to_transfer.append(pdata)
                print(f"    → {pdata['name'] or 'Unnamed'} ({pdata['faces_in_transfer']} faces) [TRANSFER]")
            else:
                persons_to_duplicate.append(pdata)
                print(f"    → {pdata['name'] or 'Unnamed'} ({pdata['faces_in_transfer']} in album, {pdata['faces_outside']} outside) [DUPLICATE]")
        
        if dry_run:
            print(f"\n  ┌────────────────────────────────────────────────────┐")
            print(f"  │                    DRY RUN                         │")
            print(f"  │              No changes were made                  │")
            print(f"  └────────────────────────────────────────────────────┘")
            result["assets_transferred"] = len(asset_ids)
            result["persons_transferred"] = len(persons_to_transfer)
            result["persons_duplicated"] = len(persons_to_duplicate)
            return result
        
        # 3. Execute transfer
        conn = None
        try:
            conn = self.connect_db()
            
            # Transfer assets
            print(f"\n  Transferring {len(asset_ids)} assets...")
            transferred = self.transfer_assets(asset_ids, new_owner_id)
            result["assets_transferred"] = transferred
            print(f"    ✓ {transferred} assets transferred")
            
            # Transfer persons only in these assets
            for pdata in persons_to_transfer:
                print(f"  Transferring person '{pdata['name'] or 'Unnamed'}'...")
                self.transfer_person(pdata["id"], new_owner_id)
                result["persons_transferred"] += 1
                print(f"    ✓ Done")
            
            # Duplicate persons in both users
            for pdata in persons_to_duplicate:
                print(f"  Duplicating person '{pdata['name'] or 'Unnamed'}'...")
                new_pid = self.duplicate_person_for_user(pdata["id"], new_owner_id, asset_ids)
                if new_pid:
                    result["persons_duplicated"] += 1
                    print(f"    ✓ New person ID: {new_pid[:8]}...")
                else:
                    result["errors"].append(f"Error duplicating person {pdata['id']}")
            
            print(f"\n  ┌────────────────────────────────────────────────────┐")
            print(f"  │              TRANSFER COMPLETED                    │")
            print(f"  └────────────────────────────────────────────────────┘")
            print(f"\n  Summary:")
            print(f"    • Assets transferred:  {result['assets_transferred']}")
            print(f"    • Persons transferred: {result['persons_transferred']}")
            print(f"    • Persons duplicated:  {result['persons_duplicated']}")
            if result["errors"]:
                print(f"    • Errors: {len(result['errors'])}")
                for err in result["errors"]:
                    print(f"      - {err}")
            
        except Exception as e:
            result["errors"].append(str(e))
            if conn:
                conn.rollback()
            print(f"\n  ✗ ERROR: {e}")
        
        return result
    
    def repair_faces_for_user(self, user_id: str, dry_run: bool = True) -> dict:
        """
        Repairs faces after a manual transfer.
        Finds faces in user's assets that belong to other users' persons,
        and duplicates those persons for the correct user.
        
        Args:
            user_id: The user whose assets need face repair
            dry_run: If True, only simulate without making changes
        
        Returns:
            dict with operation summary
        """
        result = {
            "faces_found": 0,
            "persons_duplicated": 0,
            "errors": []
        }
        
        conn = self.connect_db()
        cur = conn.cursor()
        
        # Find faces in user's assets that belong to other users' persons
        cur.execute("""
            SELECT DISTINCT p.id as person_id, p."ownerId" as person_owner, p.name,
                   COUNT(af.id) as face_count
            FROM asset a
            JOIN asset_face af ON a.id = af."assetId"
            JOIN person p ON af."personId" = p.id
            WHERE a."ownerId" = %s 
              AND p."ownerId" != %s
              AND af."personId" IS NOT NULL
            GROUP BY p.id, p."ownerId", p.name
            ORDER BY p.name
        """, (user_id, user_id))
        
        broken_persons = cur.fetchall()
        
        print(f"\n  ┌────────────────────────────────────────────────────┐")
        print(f"  │              FACE REPAIR ANALYSIS                   │")
        print(f"  └────────────────────────────────────────────────────┘")
        
        if not broken_persons:
            print(f"\n  ✓ No broken face links found!")
            cur.close()
            
            if not dry_run:
                # Still check for broken thumbnails
                print(f"\n  Checking for broken profile pictures...")
                thumbnails_fixed = self.fix_broken_thumbnails(user_id)
                result["thumbnails_fixed"] = thumbnails_fixed
                if thumbnails_fixed > 0:
                    print(f"\n  ✓ Fixed {thumbnails_fixed} profile pictures")
                else:
                    print(f"  ✓ All profile pictures are OK")
            
            return result
        
        print(f"\n  Found {len(broken_persons)} persons that need to be duplicated:\n")
        
        total_faces = 0
        for person in broken_persons:
            person_id, person_owner, name, face_count = person
            total_faces += face_count
            print(f"    → {name or 'Unnamed'} ({face_count} faces)")
        
        result["faces_found"] = total_faces
        
        if dry_run:
            print(f"\n  ┌────────────────────────────────────────────────────┐")
            print(f"  │                    DRY RUN                         │")
            print(f"  │              No changes were made                  │")
            print(f"  └────────────────────────────────────────────────────┘")
            print(f"\n  Would duplicate {len(broken_persons)} persons")
            print(f"  Would fix {total_faces} face links")
            cur.close()
            return result
        
        # Execute repair
        print(f"\n  Repairing faces...")
        
        for person in broken_persons:
            person_id, person_owner, name, face_count = person
            
            try:
                # Get all asset IDs from this user that have faces linked to this person
                cur.execute("""
                    SELECT DISTINCT a.id::text
                    FROM asset a
                    JOIN asset_face af ON a.id = af."assetId"
                    WHERE a."ownerId" = %s AND af."personId" = %s
                """, (user_id, person_id))
                asset_ids = [row[0] for row in cur.fetchall()]
                
                # Duplicate the person for the new user
                new_person_id = self.duplicate_person_for_user(person_id, user_id, asset_ids)
                
                if new_person_id:
                    result["persons_duplicated"] += 1
                    print(f"    ✓ {name or 'Unnamed'}: duplicated ({face_count} faces fixed)")
                else:
                    result["errors"].append(f"Failed to duplicate {name or person_id}")
                    
            except Exception as e:
                result["errors"].append(f"Error with {name or person_id}: {str(e)}")
        
        cur.close()
        
        # Also fix broken profile pictures
        print(f"\n  Fixing profile pictures...")
        thumbnails_fixed = self.fix_broken_thumbnails(user_id)
        result["thumbnails_fixed"] = thumbnails_fixed
        
        print(f"\n  ┌────────────────────────────────────────────────────┐")
        print(f"  │              REPAIR COMPLETED                       │")
        print(f"  └────────────────────────────────────────────────────┘")
        print(f"\n  Summary:")
        print(f"    • Persons duplicated:  {result['persons_duplicated']}")
        print(f"    • Faces fixed:         {total_faces}")
        print(f"    • Thumbnails fixed:    {thumbnails_fixed}")
        if result["errors"]:
            print(f"    • Errors: {len(result['errors'])}")
            for err in result["errors"]:
                print(f"      - {err}")
        
        return result
    
    def fix_broken_thumbnails(self, user_id: Optional[str] = None) -> int:
        """
        Fixes persons with NULL or invalid faceAssetId.
        If user_id is provided, only fixes for that user.
        Returns number of thumbnails fixed.
        """
        conn = self.connect_db()
        cur = conn.cursor()
        
        # Find persons with NULL faceAssetId or invalid faceAssetId
        if user_id:
            cur.execute("""
                SELECT p.id, p.name
                FROM person p
                WHERE p."ownerId" = %s
                  AND (p."faceAssetId" IS NULL 
                       OR NOT EXISTS (SELECT 1 FROM asset_face af WHERE af.id = p."faceAssetId"))
            """, (user_id,))
        else:
            cur.execute("""
                SELECT p.id, p.name
                FROM person p
                WHERE p."faceAssetId" IS NULL 
                   OR NOT EXISTS (SELECT 1 FROM asset_face af WHERE af.id = p."faceAssetId")
            """)
        
        broken_persons = cur.fetchall()
        fixed_count = 0
        
        for person_id, name in broken_persons:
            # Find a valid face for this person
            cur.execute("""
                SELECT id FROM asset_face WHERE "personId" = %s LIMIT 1
            """, (person_id,))
            face_row = cur.fetchone()
            
            if face_row:
                cur.execute("""
                    UPDATE person SET "faceAssetId" = %s WHERE id = %s
                """, (face_row[0], person_id))
                fixed_count += 1
                print(f"    ✓ {name or 'Unnamed'}: thumbnail fixed")
        
        conn.commit()
        cur.close()
        return fixed_count


def main():
    clear_screen()
    print_header()
    
    if not check_config():
        return
    
    # Reload config after potential setup
    from config import API_URL, API_KEY, DB_CONFIG
    
    transfer = ImmichTransfer()
    
    while True:
        clear_screen()
        print_header()
        
        print("  ┌─────────────────────────────────────┐")
        print("  │             MAIN MENU               │")
        print("  ├─────────────────────────────────────┤")
        print("  │  1.  List users                     │")
        print("  │  2.  List albums                    │")
        print("  │  3.  Transfer album (dry run)       │")
        print("  │  4.  Transfer album (EXECUTE)       │")
        print("  ├─────────────────────────────────────┤")
        print("  │  5.  Repair faces (dry run)         │")
        print("  │  6.  Repair faces (EXECUTE)         │")
        print("  ├─────────────────────────────────────┤")
        print("  │  7.  Reconfigure                    │")
        print("  │  8.  Clear config                   │")
        print("  │  0.  Exit                           │")
        print("  └─────────────────────────────────────┘")
        
        choice = input("\n  Select option: ").strip()
        
        if choice == "1":
            print_section("USERS")
            try:
                users = transfer.get_users()
                for u in users:
                    print(f"    {u['name']}")
                    print(f"    ID: {u['id']}")
                    print()
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "2":
            print_section("ALBUMS (all users)")
            try:
                albums = transfer.get_all_albums_db()
                for a in albums:
                    print(f"    [{a['ownerName']}] {a['albumName']}")
                    print(f"    {a['assetCount']} items | ID: {a['id']}")
                    print()
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "3" or choice == "4":
            is_dry_run = choice == "3"
            print_section("TRANSFER ALBUM" + (" (Dry Run)" if is_dry_run else " (EXECUTE)"))
            
            if not is_dry_run:
                print("  ⚠ WARNING: This will modify the database!")
                print()
            
            try:
                # 1. Select source user
                users = transfer.get_users()
                print("  Select SOURCE user (transfer FROM):\n")
                for i, u in enumerate(users, 1):
                    print(f"    {i}. {u['name']}")
                
                src_choice = input("\n  > ").strip()
                if not src_choice.isdigit() or int(src_choice) < 1 or int(src_choice) > len(users):
                    print("  ✗ Invalid selection")
                    input("\n  Press Enter to continue...")
                    continue
                source_user = users[int(src_choice) - 1]
                
                # 2. Get albums from source user
                albums = transfer.get_all_albums_db()
                user_albums = [a for a in albums if a['ownerId'] == source_user['id']]
                
                if not user_albums:
                    print(f"\n  ✗ No albums found for {source_user['name']}")
                    input("\n  Press Enter to continue...")
                    continue
                
                print(f"\n  Albums from {source_user['name']}:\n")
                for i, a in enumerate(user_albums, 1):
                    print(f"    {i}. {a['albumName']} ({a['assetCount']} items)")
                
                album_choice = input("\n  > ").strip()
                if not album_choice.isdigit() or int(album_choice) < 1 or int(album_choice) > len(user_albums):
                    print("  ✗ Invalid selection")
                    input("\n  Press Enter to continue...")
                    continue
                selected_album = user_albums[int(album_choice) - 1]
                
                # 3. Select destination user
                other_users = [u for u in users if u['id'] != source_user['id']]
                if not other_users:
                    print("\n  ✗ No other users available")
                    input("\n  Press Enter to continue...")
                    continue
                
                print(f"\n  Select DESTINATION user (transfer TO):\n")
                for i, u in enumerate(other_users, 1):
                    print(f"    {i}. {u['name']}")
                
                dest_choice = input("\n  > ").strip()
                if not dest_choice.isdigit() or int(dest_choice) < 1 or int(dest_choice) > len(other_users):
                    print("  ✗ Invalid selection")
                    input("\n  Press Enter to continue...")
                    continue
                dest_user = other_users[int(dest_choice) - 1]
                
                # 4. Confirm
                print(f"\n  ┌────────────────────────────────────────────────────┐")
                print(f"  │                 TRANSFER SUMMARY                   │")
                print(f"  └────────────────────────────────────────────────────┘")
                print(f"\n  Album:       {selected_album['albumName']}")
                print(f"  Items:       {selected_album['assetCount']}")
                print(f"  From:        {source_user['name']}")
                print(f"  To:          {dest_user['name']}")
                
                if is_dry_run:
                    print("\n  Mode:        DRY RUN (no changes)")
                    input("\n  Press Enter to analyze...")
                    transfer.transfer_album_with_faces(selected_album['id'], dest_user['id'], dry_run=True)
                else:
                    print("\n  Mode:        EXECUTE (will modify database!)")
                    confirm = input("\n  Type 'yes' to confirm: ").strip().lower()
                    if confirm == 'yes':
                        transfer.transfer_album_with_faces(selected_album['id'], dest_user['id'], dry_run=False)
                    else:
                        print("\n  ✗ Cancelled.")
                
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "5" or choice == "6":
            is_dry_run = choice == "5"
            print_section("REPAIR FACES" + (" (Dry Run)" if is_dry_run else " (EXECUTE)"))
            
            if not is_dry_run:
                print("  ⚠ WARNING: This will modify the database!")
                print()
            
            print("  This fixes faces after a manual photo transfer.")
            print("  It finds faces linked to wrong users and duplicates")
            print("  the persons for the correct user.\n")
            
            try:
                users = transfer.get_users()
                print("  Select user to repair faces for:\n")
                for i, u in enumerate(users, 1):
                    print(f"    {i}. {u['name']}")
                
                user_choice = input("\n  > ").strip()
                if not user_choice.isdigit() or int(user_choice) < 1 or int(user_choice) > len(users):
                    print("  ✗ Invalid selection")
                    input("\n  Press Enter to continue...")
                    continue
                selected_user = users[int(user_choice) - 1]
                
                print(f"\n  Analyzing faces for {selected_user['name']}...")
                
                if is_dry_run:
                    transfer.repair_faces_for_user(selected_user['id'], dry_run=True)
                else:
                    confirm = input(f"\n  Repair faces for {selected_user['name']}? Type 'yes' to confirm: ").strip().lower()
                    if confirm == 'yes':
                        transfer.repair_faces_for_user(selected_user['id'], dry_run=False)
                    else:
                        print("\n  ✗ Cancelled.")
                
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "7":
            setup_config()
            print("\n  Restarting with new configuration...")
            # Reload
            import importlib
            import config
            importlib.reload(config)
            transfer = ImmichTransfer()
        
        elif choice == "8":
            confirm = input("\n  Clear all configuration? (y/n): ").strip().lower()
            if confirm == 'y':
                clear_config()
                print("\n  Please restart the tool.")
                break
        
        elif choice == "0":
            break
        
        else:
            print("  ✗ Invalid option")
            input("\n  Press Enter to continue...")
    
    transfer.close_db()
    print("\n  Goodbye!\n")


if __name__ == "__main__":
    main()
