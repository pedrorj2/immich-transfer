#!/usr/bin/env python3
"""
Immich Transfer Tool
Transfer photos between users in Immich, including faces and metadata.
"""

import requests
import psycopg2
import uuid
import os
from typing import Optional

# Try to import config, or use empty values
try:
    from config import API_URL, API_KEY, DB_CONFIG
except ImportError:
    API_URL = ""
    API_KEY = ""
    DB_CONFIG = {"host": "", "port": 5432, "database": "immichdb", "user": "immich", "password": ""}


def clear_screen():
    """Clear terminal screen"""
    os.system('cls' if os.name == 'nt' else 'clear')


def print_header():
    """Print application header"""
    print()
    print("  ╔══════════════════════════════════════════════════════════╗")
    print("  ║                   IMMICH TRANSFER TOOL                   ║")
    print("  ║          Transfer photos between users safely            ║")
    print("  ║                                                          ║")
    print("  ║            github.com/pedrorj2/immich-transfer           ║")
    print("  ╚══════════════════════════════════════════════════════════╝")
    print()


def print_section(title: str):
    """Print a section header"""
    print(f"\n  ┌{'─' * (len(title) + 2)}┐")
    print(f"  │ {title} │")
    print(f"  └{'─' * (len(title) + 2)}┘\n")


def setup_config():
    """Interactive configuration setup"""
    clear_screen()
    print_header()
    print_section("CONFIGURATION SETUP")
    
    # API URL
    print("  Immich API URL")
    print("  Example: http://192.168.1.6:2283")
    api_url = input("  > ").strip()
    if not api_url.endswith("/api"):
        api_url = api_url.rstrip("/") + "/api"
    
    # API Key
    print("\n  Admin API Key")
    print("  Get it from: Immich → Profile → Account Settings → API Keys")
    api_key = input("  > ").strip()
    
    # Database
    print_section("PostgreSQL Configuration")
    
    print("  Database Host")
    print("  Example: 192.168.1.6 or immich_postgres (if running on same server)")
    db_host = input("  > ").strip()
    
    print("\n  Database Port [5432]")
    db_port = input("  > ").strip() or "5432"
    
    print("\n  Database Name [immichdb]")
    db_name = input("  > ").strip() or "immichdb"
    
    print("\n  Database Username [immich]")
    db_user = input("  > ").strip() or "immich"
    
    print("\n  Database Password")
    print("  Find it with: docker exec -t immich_postgres env | grep POSTGRES_PASSWORD")
    db_pass = input("  > ").strip()
    
    # Write config file
    config_content = f'''# Immich Transfer Configuration
# Auto-generated by setup

# Immich API URL
API_URL = "{api_url}"

# API Key with admin permissions
API_KEY = "{api_key}"

# PostgreSQL connection
DB_CONFIG = {{
    "host": "{db_host}",
    "port": {db_port},
    "database": "{db_name}",
    "user": "{db_user}",
    "password": "{db_pass}"
}}
'''
    
    config_path = os.path.join(os.path.dirname(__file__), "config.py")
    with open(config_path, "w") as f:
        f.write(config_content)
    
    print(f"\n  ✓ Configuration saved to {config_path}")
    input("\n  Press Enter to continue...")
    return api_url, api_key, {"host": db_host, "port": int(db_port), "database": db_name, "user": db_user, "password": db_pass}


def clear_config():
    """Clear configuration file"""
    config_content = '''# Immich Transfer Configuration
# Run the tool to set up interactively

API_URL = ""
API_KEY = ""
DB_CONFIG = {
    "host": "",
    "port": 5432,
    "database": "immichdb",
    "user": "immich",
    "password": ""
}
'''
    config_path = os.path.join(os.path.dirname(__file__), "config.py")
    with open(config_path, "w") as f:
        f.write(config_content)
    print("\n  ✓ Configuration cleared")
    input("\n  Press Enter to continue...")


def check_config():
    """Check if config is valid, offer setup if not"""
    global API_URL, API_KEY, DB_CONFIG
    
    if not API_URL or not API_KEY or not DB_CONFIG.get("host") or not DB_CONFIG.get("password"):
        print("\n  ⚠ Configuration not found or incomplete.")
        choice = input("  Run setup now? (y/n): ").strip().lower()
        if choice == 'y':
            API_URL, API_KEY, DB_CONFIG = setup_config()
            return True
        else:
            print("  Please edit config.py manually.")
            return False
    return True


class ImmichTransfer:
    def __init__(self, api_url=None, api_key=None, db_config=None):
        self.api_url = api_url or API_URL
        self.api_key = api_key or API_KEY
        self.db_config = db_config or DB_CONFIG
        self.headers = {
            "x-api-key": self.api_key,
            "Content-Type": "application/json"
        }
        self.conn = None
    
    # ==================== API METHODS ====================
    
    def get_users(self) -> list:
        """Get list of users"""
        resp = requests.get(f"{self.api_url}/users", headers=self.headers)
        resp.raise_for_status()
        return resp.json()
    
    def get_albums(self) -> list:
        """Get list of albums (via API, only current user's)"""
        resp = requests.get(f"{self.api_url}/albums", headers=self.headers)
        resp.raise_for_status()
        return resp.json()
    
    def get_all_albums_db(self) -> list:
        """Get ALL albums from all users via DB"""
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT a.id, a."albumName", a."ownerId", u.name as owner_name,
                   (SELECT COUNT(*) FROM album_asset aa WHERE aa."albumId" = a.id) as asset_count
            FROM album a
            LEFT JOIN "user" u ON a."ownerId" = u.id
            ORDER BY u.name, a."albumName"
        """)
        albums = []
        for row in cur.fetchall():
            albums.append({
                "id": row[0],
                "albumName": row[1],
                "ownerId": row[2],
                "ownerName": row[3],
                "assetCount": row[4]
            })
        cur.close()
        return albums
    
    def get_album_assets(self, album_id: str) -> list:
        """Get asset IDs from an album"""
        resp = requests.get(f"{self.api_url}/albums/{album_id}", headers=self.headers)
        resp.raise_for_status()
        album = resp.json()
        return [asset["id"] for asset in album.get("assets", [])]
    
    def get_tags(self) -> list:
        """Get list of tags"""
        resp = requests.get(f"{self.api_url}/tags", headers=self.headers)
        resp.raise_for_status()
        return resp.json()
    
    # ==================== DATABASE METHODS ====================
    
    def connect_db(self):
        """Connect to database"""
        if self.conn is None or self.conn.closed:
            self.conn = psycopg2.connect(**self.db_config)
        return self.conn
    
    def close_db(self):
        """Close database connection"""
        if self.conn and not self.conn.closed:
            self.conn.close()
    
    def get_assets_by_album(self, album_id: str) -> list:
        """Obtiene asset IDs de un álbum desde la DB"""
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT "assetId" FROM album_asset WHERE "albumId" = %s
        """, (album_id,))
        assets = [row[0] for row in cur.fetchall()]
        cur.close()
        return assets
    
    def get_faces_for_assets(self, asset_ids: list) -> list:
        """Obtiene las caras asociadas a una lista de assets"""
        if not asset_ids:
            return []
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            SELECT af.id, af."assetId", af."personId", p."ownerId", p.name
            FROM asset_face af
            LEFT JOIN person p ON af."personId" = p.id
            WHERE af."assetId" = ANY(%s)
        """, (asset_ids,))
        faces = cur.fetchall()
        cur.close()
        return faces
    
    def get_persons_for_assets(self, asset_ids: list) -> dict:
        """
        Obtiene las personas únicas que aparecen en los assets.
        Retorna dict con info de cada persona y si tiene caras fuera de estos assets.
        """
        if not asset_ids:
            return {}
        
        conn = self.connect_db()
        cur = conn.cursor()
        
        # Personas que aparecen en los assets a transferir
        cur.execute("""
            SELECT DISTINCT af."personId"
            FROM asset_face af
            WHERE af."assetId" = ANY(%s) AND af."personId" IS NOT NULL
        """, (asset_ids,))
        person_ids = [row[0] for row in cur.fetchall()]
        
        if not person_ids:
            cur.close()
            return {}
        
        persons = {}
        for person_id in person_ids:
            # Info de la persona
            cur.execute("""
                SELECT id, "ownerId", name, "thumbnailPath", "isHidden", "birthDate", 
                       "faceAssetId", "isFavorite", color
                FROM person WHERE id = %s
            """, (person_id,))
            person_data = cur.fetchone()
            
            if not person_data:
                continue
            
            # Contar caras dentro y fuera de los assets a transferir
            cur.execute("""
                SELECT 
                    COUNT(*) FILTER (WHERE "assetId" = ANY(%s)) as faces_in_transfer,
                    COUNT(*) FILTER (WHERE "assetId" != ALL(%s)) as faces_outside
                FROM asset_face
                WHERE "personId" = %s
            """, (asset_ids, asset_ids, person_id))
            counts = cur.fetchone()
            
            persons[person_id] = {
                "id": person_data[0],
                "ownerId": person_data[1],
                "name": person_data[2],
                "thumbnailPath": person_data[3],
                "isHidden": person_data[4],
                "birthDate": person_data[5],
                "faceAssetId": person_data[6],
                "isFavorite": person_data[7],
                "color": person_data[8],
                "faces_in_transfer": counts[0],
                "faces_outside": counts[1]
            }
        
        cur.close()
        return persons
    
    def transfer_assets(self, asset_ids: list, new_owner_id: str) -> int:
        """Transfiere la propiedad de los assets"""
        if not asset_ids:
            return 0
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE asset SET "ownerId" = %s WHERE id = ANY(%s)
        """, (new_owner_id, asset_ids))
        count = cur.rowcount
        conn.commit()
        cur.close()
        return count
    
    def transfer_person(self, person_id: str, new_owner_id: str):
        """Transfiere una persona completa a otro usuario"""
        conn = self.connect_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE person SET "ownerId" = %s WHERE id = %s
        """, (new_owner_id, person_id))
        conn.commit()
        cur.close()
    
    def duplicate_person_for_user(self, person_id: str, new_owner_id: str, asset_ids: list) -> Optional[str]:
        """
        Duplica una persona para el nuevo usuario.
        Solo re-vincula las caras de los assets transferidos.
        Retorna el ID de la nueva persona.
        """
        conn = self.connect_db()
        cur = conn.cursor()
        
        # Obtener datos de la persona original
        cur.execute("""
            SELECT name, "isHidden", "birthDate", "isFavorite", color
            FROM person WHERE id = %s
        """, (person_id,))
        original = cur.fetchone()
        
        if not original:
            cur.close()
            return None
        
        # Crear nueva persona para el nuevo usuario
        new_person_id = str(uuid.uuid4())
        cur.execute("""
            INSERT INTO person (id, "ownerId", name, "isHidden", "birthDate", "isFavorite", color, "createdAt", "updatedAt")
            VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
        """, (new_person_id, new_owner_id, original[0], original[1], original[2], original[3], original[4]))
        
        # Re-vincular las caras de los assets transferidos a la nueva persona
        cur.execute("""
            UPDATE asset_face 
            SET "personId" = %s 
            WHERE "personId" = %s AND "assetId" = ANY(%s)
        """, (new_person_id, person_id, asset_ids))
        
        # Copiar embeddings de las caras transferidas
        cur.execute("""
            SELECT af.id 
            FROM asset_face af 
            WHERE af."personId" = %s
        """, (new_person_id,))
        new_face_ids = [row[0] for row in cur.fetchall()]
        
        # Actualizar faceAssetId de la nueva persona (usar la primera cara disponible)
        if new_face_ids:
            cur.execute("""
                SELECT "assetId" FROM asset_face WHERE id = %s
            """, (new_face_ids[0],))
            first_asset = cur.fetchone()
            if first_asset:
                cur.execute("""
                    UPDATE person SET "faceAssetId" = %s WHERE id = %s
                """, (first_asset[0], new_person_id))
        
        conn.commit()
        cur.close()
        return new_person_id
    
    def transfer_album_with_faces(self, album_id: str, new_owner_id: str, dry_run: bool = True) -> dict:
        """
        Transfer an album with all associated faces.
        
        Args:
            album_id: Album ID to transfer
            new_owner_id: Destination user ID
            dry_run: If True, only simulate without making changes
        
        Returns:
            dict with operation summary
        """
        result = {
            "assets_transferred": 0,
            "persons_transferred": 0,
            "persons_duplicated": 0,
            "errors": []
        }
        
        # 1. Get album assets
        asset_ids = self.get_assets_by_album(album_id)
        if not asset_ids:
            result["errors"].append("No assets found in album")
            return result
        
        print(f"\n  ┌────────────────────────────────────────────────────┐")
        print(f"  │              ALBUM TRANSFER ANALYSIS                │")
        print(f"  └────────────────────────────────────────────────────┘")
        print(f"\n  Assets to transfer: {len(asset_ids)}")
        
        # 2. Analyze affected persons
        persons = self.get_persons_for_assets(asset_ids)
        print(f"  Persons detected: {len(persons)}")
        
        persons_to_transfer = []  # Persons only in these assets
        persons_to_duplicate = []  # Persons in both
        
        if persons:
            print(f"\n  Person analysis:")
        for pid, pdata in persons.items():
            if pdata["faces_outside"] == 0:
                persons_to_transfer.append(pdata)
                print(f"    → {pdata['name'] or 'Unnamed'} ({pdata['faces_in_transfer']} faces) [TRANSFER]")
            else:
                persons_to_duplicate.append(pdata)
                print(f"    → {pdata['name'] or 'Unnamed'} ({pdata['faces_in_transfer']} in album, {pdata['faces_outside']} outside) [DUPLICATE]")
        
        if dry_run:
            print(f"\n  ┌────────────────────────────────────────────────────┐")
            print(f"  │                    DRY RUN                         │")
            print(f"  │              No changes were made                  │")
            print(f"  └────────────────────────────────────────────────────┘")
            result["assets_transferred"] = len(asset_ids)
            result["persons_transferred"] = len(persons_to_transfer)
            result["persons_duplicated"] = len(persons_to_duplicate)
            return result
        
        # 3. Execute transfer
        conn = None
        try:
            conn = self.connect_db()
            
            # Transfer assets
            print(f"\n  Transferring {len(asset_ids)} assets...")
            transferred = self.transfer_assets(asset_ids, new_owner_id)
            result["assets_transferred"] = transferred
            print(f"    ✓ {transferred} assets transferred")
            
            # Transfer persons only in these assets
            for pdata in persons_to_transfer:
                print(f"  Transferring person '{pdata['name'] or 'Unnamed'}'...")
                self.transfer_person(pdata["id"], new_owner_id)
                result["persons_transferred"] += 1
                print(f"    ✓ Done")
            
            # Duplicate persons in both users
            for pdata in persons_to_duplicate:
                print(f"  Duplicating person '{pdata['name'] or 'Unnamed'}'...")
                new_pid = self.duplicate_person_for_user(pdata["id"], new_owner_id, asset_ids)
                if new_pid:
                    result["persons_duplicated"] += 1
                    print(f"    ✓ New person ID: {new_pid[:8]}...")
                else:
                    result["errors"].append(f"Error duplicating person {pdata['id']}")
            
            print(f"\n  ┌────────────────────────────────────────────────────┐")
            print(f"  │              TRANSFER COMPLETED                    │")
            print(f"  └────────────────────────────────────────────────────┘")
            print(f"\n  Summary:")
            print(f"    • Assets transferred:  {result['assets_transferred']}")
            print(f"    • Persons transferred: {result['persons_transferred']}")
            print(f"    • Persons duplicated:  {result['persons_duplicated']}")
            if result["errors"]:
                print(f"    • Errors: {len(result['errors'])}")
                for err in result["errors"]:
                    print(f"      - {err}")
            
        except Exception as e:
            result["errors"].append(str(e))
            if conn:
                conn.rollback()
            print(f"\n  ✗ ERROR: {e}")
        
        return result


def main():
    clear_screen()
    print_header()
    
    if not check_config():
        return
    
    # Reload config after potential setup
    from config import API_URL, API_KEY, DB_CONFIG
    
    transfer = ImmichTransfer()
    
    while True:
        clear_screen()
        print_header()
        
        print("  ┌─────────────────────────────────────┐")
        print("  │             MAIN MENU               │")
        print("  ├─────────────────────────────────────┤")
        print("  │  1.  List users                     │")
        print("  │  2.  List albums                    │")
        print("  │  3.  Transfer album (dry run)       │")
        print("  │  4.  Transfer album (EXECUTE)       │")
        print("  ├─────────────────────────────────────┤")
        print("  │  5.  Reconfigure                    │")
        print("  │  6.  Clear config                   │")
        print("  │  0.  Exit                           │")
        print("  └─────────────────────────────────────┘")
        
        choice = input("\n  Select option: ").strip()
        
        if choice == "1":
            print_section("USERS")
            try:
                users = transfer.get_users()
                for u in users:
                    print(f"    {u['name']}")
                    print(f"    ID: {u['id']}")
                    print()
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "2":
            print_section("ALBUMS (all users)")
            try:
                albums = transfer.get_all_albums_db()
                for a in albums:
                    print(f"    [{a['ownerName']}] {a['albumName']}")
                    print(f"    {a['assetCount']} items | ID: {a['id']}")
                    print()
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "3":
            print_section("TRANSFER ALBUM (Dry Run)")
            album_id = input("  Album ID: ").strip()
            try:
                users = transfer.get_users()
                print("\n  Available users:")
                for u in users:
                    print(f"    - {u['name']} (ID: {u['id']})")
                new_owner = input("\n  New owner ID: ").strip()
                transfer.transfer_album_with_faces(album_id, new_owner, dry_run=True)
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "4":
            print_section("TRANSFER ALBUM (EXECUTE)")
            print("  ⚠ WARNING: This will modify the database!")
            print()
            album_id = input("  Album ID: ").strip()
            try:
                users = transfer.get_users()
                print("\n  Available users:")
                for u in users:
                    print(f"    - {u['name']} (ID: {u['id']})")
                new_owner = input("\n  New owner ID: ").strip()
                
                confirm = input("\n  ARE YOU SURE? Type 'yes' to confirm: ").strip().lower()
                if confirm == 'yes':
                    transfer.transfer_album_with_faces(album_id, new_owner, dry_run=False)
                else:
                    print("\n  ✗ Cancelled.")
            except Exception as e:
                print(f"  ✗ Error: {e}")
            input("\n  Press Enter to continue...")
        
        elif choice == "5":
            setup_config()
            print("\n  Restarting with new configuration...")
            # Reload
            import importlib
            import config
            importlib.reload(config)
            transfer = ImmichTransfer()
        
        elif choice == "6":
            confirm = input("\n  Clear all configuration? (y/n): ").strip().lower()
            if confirm == 'y':
                clear_config()
                print("\n  Please restart the tool.")
                break
        
        elif choice == "0":
            break
        
        else:
            print("  ✗ Invalid option")
            input("\n  Press Enter to continue...")
    
    transfer.close_db()
    print("\n  Goodbye!\n")


if __name__ == "__main__":
    main()
